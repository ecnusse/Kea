import json
import os
import re
import functools
from datetime import datetime
import time
import pkg_resources
# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile(
    '^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
    '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$'
)


def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess

    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random

    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib

    return hashlib.md5(input_str.encode('utf-8')).hexdigest()


def safe_get_dict(view_dict, key, default=None):
    return view_dict[key] if (key in view_dict) else default


def generate_report(img_path, html_path, bug_information=None):
    '''Generate report for the test based on the executed events'''
    line_list = []
    
    bug_link_list = []
    # user can click to jump to the corresponding event, contains the event index of each bug
    bug_set = set()
    if bug_information is not None:
        for bug in bug_information:
            property_name = "<p><strong>" + bug[2] + "</strong></p>"
            bug_link = ( property_name + "<li><a href=\"#"+str(bug[0])+"\">"+str(bug[0])+"</a></li>" + '\n')
            bug_link_list.append(bug_link)
            bug_set.add(bug[0])
    f_html = open(
        os.path.join(html_path,  "bug_report.html"), 'w', encoding='utf-8'
    )
    f_style = pkg_resources.resource_filename(
                "kea", "resources/style/style.html"
            )
    f_style = open(f_style, 'r', encoding='utf-8')
    # f_style = open("droidbot/resources/style/style.html", 'r', encoding='utf-8')
    img_list = os.listdir(img_path)
    sorted_img_list = sorted(
        img_list, key=lambda x: os.path.getmtime(os.path.join(img_path, x))
    )
    new_str = "<ul id=\"menu\">" + '\n'
    new_bug_str = ""
    for img_name in sorted_img_list:
        if ".png" in img_name:

            state_num = 1

            img_file = os.path.join("every_states", img_name)
            json_dir = os.path.join(html_path, "report_screen_shoot.json")
            with open(json_dir, 'r') as json_file:
                report_screens = json.load(json_file)
            report_screen = list(filter(lambda person: person["screen_shoot"] == img_name, report_screens))
            report_screen = report_screen[0]
            action_count = report_screen['event_index']
            event_name = report_screen['event']
            line = (
                "      <li><img src=\""
                + img_file
                + "\" class=\"img\"><p>"
                + action_count+ " " + event_name
                + "</p></li>"
                + '\n'
            )
            if bug_information is not None:
                if "." not in action_count and int(action_count) in bug_set:
                    line = (
                        "      <li><img src=\""
                        + img_file
                        + "\" class=\"img\""
                        + " id=\""
                        + action_count
                        + "\">"
                        +"<p>"
                        + action_count+ " " + event_name
                        + "</p></li>"
                        + '\n'
                    )             
            line_list.append((float(state_num), line))
    for item in line_list:
        new_str = new_str + item[1]
    for item in bug_link_list:
        new_bug_str = new_bug_str + item
    new_str = new_str + "   </ul>"
    old_str = "<ul id=\"menu\"></ul>"
    old_bug_str = "bug_link"
    for line in f_style:
        if bug_information is not None and "<ul>bug_link</ul>" in line:
            # f_html.write(re.sub(old_bug_str,new_bug_str,line))
            f_html.write(line.replace(old_bug_str, new_bug_str))
            continue
        # f_html.write(re.sub(old_str, new_str, line))
        f_html.write(line.replace(old_str, new_str))
        

class Time(object):
    def __init__(self):
        self.start_time = time.time()

    def get_time_duration(self):
        return str(int(time.time() - self.start_time))
