from dataclasses import dataclass
import json
import logging
import os
import re
import functools
from datetime import datetime
import time
import warnings
import pkg_resources  # TODO: warning pkg_resources has been depreciated
import yaml
from dataclasses import dataclass
# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile(
    '^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+'
    '(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$'
)

RULE_MARKER = "tool_rule"
INITIALIZER_MARKER = "tool_initializer"
PRECONDITIONS_MARKER = "tool_preconditions"
INVARIANT_MARKER = "tool_invariant"
MAINPATH_MARKER = "tool_mainPath"

DEFAULT_POLICY = "random"
RANDOM_POLICY = "random"
DEFAULT_EVENT_INTERVAL = 1
DEFAULT_EVENT_COUNT = 100000000
DEFAULT_TIMEOUT = 3600

@dataclass
class COLOR:
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    RED = (0, 0, 255)
    GREEN = (0, 255, 0)
    BLUE = (255, 0, 0)
    YELLOW = (0, 255, 255)
    CYAN = (255, 255, 0)
    MAGENTA = (255, 0, 255)

@dataclass
class RULE_STATE:
    PRECONDITION_SATISFIED = "#satisfy pre"
    PROPERTY_CHECKED = "#check property"
    POSTCONDITION_VIOLATED = "#postcondition is violated"
    UI_OBJECT_NOT_FOUND = "#UI object not found"

def lazy_property(func):
    attribute = '_lazy_' + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group('date')
    time = m.group('time')
    log_dict['pid'] = m.group('pid')
    log_dict['tid'] = m.group('tid')
    log_dict['level'] = m.group('level')
    log_dict['tag'] = m.group('tag')
    log_dict['content'] = m.group('content')
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict['datetime'] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess

    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random

    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib

    return hashlib.md5(input_str.encode('utf-8')).hexdigest()


def safe_get_dict(view_dict, key, default=None):
    return view_dict[key] if (key in view_dict) else default


def generate_report(img_path, html_path, bug_information=None, precondition_information=None, total_count = 0, total_time = 0, statistics_of_rules = None):
    '''Generate report for the test based on the executed events'''
    line_list = []
    bug_link_list = []
    # user can click to jump to the corresponding event, contains the event index of each bug
    bug_set = set()
    statistics = []
    json_dir = os.path.join(html_path, "report_screenshot.json")
    with open(json_dir, 'r') as json_file:
        report_screens = json.load(json_file)
    if bug_information is not None:
        for index, bug in enumerate(bug_information):
            property_name = "<p>" + bug[2] + "</p>"
            for report_screen in report_screens:
                if str(bug[0]) + "." in report_screen['event_index']:
                    interaction_end = report_screen['event_index']
            bug_link = ("<tr><td>" + str(index + 1) + "</td>" +
                        "<td>" + property_name + "</td>" +
                        "<td><a href=\"#"+str(bug[0][0] + 1)+"\">"+str(bug[0][0] + 1)+"</a></td>" +
                        "<td><a href=\"#"+str(bug[0][1] + 1) + "\">"+str(bug[0][0] + 1)+ " ~ " + str(bug[0][1] + 1) + "</a></td>" +
                        "<td><a href=\"#"+str(bug[0][1] + 1) + "\">"+str(bug[0][1] + 1)+"</a></td></tr>")
            bug_link_list.append(bug_link)
            bug_set.add(str(bug[0][0] + 1))
            bug_set.add(str(bug[0][1] + 1))
    if statistics_of_rules is not None:
        for index, statistic_rule in enumerate(statistics_of_rules):
            statistic = ("<tr><td>" + str(index + 1) + "</td>" +
                         "<td>" + statistic_rule + "</td>" +
                         "<td>" + str(statistics_of_rules[statistic_rule][RULE_STATE.PRECONDITION_SATISFIED]) + "</td>" +
                         "<td>" + str(statistics_of_rules[statistic_rule][RULE_STATE.PROPERTY_CHECKED]) + "</td>" +
                         "<td>" + str(statistics_of_rules[statistic_rule][RULE_STATE.POSTCONDITION_VIOLATED]) + "</td>" +
                         "<td>" + str(statistics_of_rules[statistic_rule][RULE_STATE.UI_OBJECT_NOT_FOUND]) + "</td></tr>"
                         )
            statistics.append(statistic)
    f_html = open(
        os.path.join(html_path,  "bug_report.html"), 'w', encoding='utf-8'
    )
    f_style = pkg_resources.resource_filename(
                "kea", "resources/style/style.html"
            )
    f_style = open(f_style, 'r', encoding='utf-8')
    # f_style = open("droidbot/resources/style/style.html", 'r', encoding='utf-8')
    new_str = "<ul id=\"menu\">" + '\n'
    new_bug_str = ""
    new_statistic_str = ""
    for report_screen in report_screens:
        action_count = report_screen['event_index']
        event_name = report_screen['event']
        img_name = report_screen['screen_shoot']
        img_file = os.path.join("all_states", img_name)
        line = (
            "      <li><img src=\""
            + img_file
            + "\" class=\"img\"><p>"
            + action_count+ " " + event_name
            + "</p></li>"
            + '\n'
        )
        if bug_information is not None:
            if action_count in bug_set:
                line = (
                    "      <li><img src=\""
                    + img_file
                    + "\" class=\"img\""
                    + " id=\""
                    + action_count
                    + "\">"
                    +"<p>"
                    + action_count+ " " + event_name
                    + "</p></li>"
                    + '\n'
                )
        line_list.append(line)
    for item in line_list:
        new_str = new_str + item
    for item in bug_link_list:
        new_bug_str = new_bug_str + item
    for item in statistics:
        new_statistic_str = new_statistic_str + item

    if len(bug_information) > 0:
        first_bug_infor = ("<div style=\"color:red;\">Time needed to found the first bug: " + str(bug_information[0][1]) + " seconds</div><br>")
    else:
        first_bug_infor = ("<div style=\"color:green;\">No bug was found.</div><br>")
    if len(precondition_information) > 0:
        first_pre_infor = ("<div>Time needed to satisfy the precondition at the first time: " + str(precondition_information[0]) + " seconds</div><br>")
    else:
        first_pre_infor = ("<div style=\"color:red;\">No precondition has been satisfied.</div><br>")

    total_time_str = "<div>Total Testing Time: " + str(total_time) + " seconds</div>"

    new_str = new_str + "   </ul>"
    old_str = "<ul id=\"menu\"></ul>"
    old_bug_str = "<tr><td>bug_link</td><td>bug_link</td><td>bug_link</td><td>bug_link</td></tr>"
    old_first_str="<div>Time</div>"
    old_num_str="<div>Num</div>"
    old_statistic_str="<tr><td>property statistic</td><td>property statistic</td><td>property statistic</td><td>property statistic</td></tr>"
    if bug_information is None or len(bug_information) == 0:
        new_num_str = "<div style=\"color:green;\">Found 0 bugs.</div><br>"
    else:
        new_num_str = "<div style=\"color:red;\">Found " + str(len(bug_information)) + " bugs.</div><br>"

    if precondition_information is not None:
        new_num_str = new_num_str + "<div> Satisfied "+ str(len(precondition_information)) + " preconditions</div><br>" + "<div>Total Executed Events: " + str(total_count) + " </div>"
    else:
        new_num_str = new_num_str + "<div>Satisfied 0 preconditions.</div>"
    for line in f_style:
        if bug_information is not None and old_bug_str in line:
            f_html.write(line.replace(old_bug_str, new_bug_str))
            continue
        if old_str in line:
            f_html.write(line.replace(old_str, new_str))
            continue
        if old_first_str in line:
            f_html.write(line.replace(old_first_str, first_bug_infor + first_pre_infor + total_time_str))
            continue
        if old_num_str in line:
            f_html.write(line.replace(old_num_str, new_num_str))
            continue
        if old_statistic_str in line:
            f_html.write(line.replace(old_statistic_str, new_statistic_str))
            continue
        f_html.write(line)

def get_yml_config()->dict[str,str]:
    if not any(os.path.exists(ymal_path := os.path.join(os.getcwd(), _)) for _ in ["config.yml", "config.yaml"]):
        raise FileNotFoundError("config.yml not found")

    with open(ymal_path, "r") as fp:
        config_dir:dict[str, str] = yaml.safe_load(fp)
    
    return config_dir

def deprecated(reason):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            warnings.warn(f"Function '{func.__name__}' is deprecated: {reason}", DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)
        return wrapper
    return decorator

class Time(object):
    def __init__(self):
        self.start_time = time.time()

    def get_time_duration(self):
        return str(int(time.time() - self.start_time))

class SingletonMeta(type):
    """
    The Singleton class can be implemented in different ways in Python. Some
    possible methods include: base class, decorator, metaclass. We will use the
    metaclass because it is best suited for this purpose.
    """

    _instances = {}

    def __call__(cls, *args, **kwargs):
        """
        Possible changes to the value of the `__init__` argument do not affect
        the returned instance.
        """
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]

def sanitize_app_package_name(options):
    """validate whether the app with the package name has been already installed on the device
    """
    import subprocess

    if options.device_serial is None:
        raise AttributeError(f"device serial is None") 

    package_list = []
    if not options.is_harmonyos:
        cmd = ["adb", "-s", options.device_serial, "shell", "pm", "list", "package"] 
        dump_packages = subprocess.check_output(cmd, text=True)
        package_list = [_.split(":")[-1] for _ in dump_packages.split()]
    else:
        from .adapter.hdc import HDC_EXEC
        cmd = [HDC_EXEC, "-t", options.device_serial, "shell", "bm", "dump", "-a"]
        dump_packages = subprocess.check_output(cmd, text=True)
        package_list = dump_packages.split()

    if not (package_name := options.apk_path) in package_list:
        raise AttributeError(f"No pacakge named {package_name} installed on device.") 
    else:
        print(f"pacakge named {package_name} is valid and already installed on device.")
        
def sanitize_args(options):
    """sanitize of the args
    
    If the device serial has not been specified, the serial of the connected device will be automatically identified.
    Note that this identification only works when *only* one device is connected.

    The args `apk_path` and `property_files` are required.

    If `apk_path` is not an apk file or a hap file, `apk_path` will be checked to see whether it denotes a valid app package name.
    It allows us to test any existing app which has already been installed on the device.
    """
    if options.device_serial is None:   
        identify_device_serial(options=options) 

    if options.apk_path is None:
        raise AttributeError("No target app. Use -a to specify the app to be tested")
    
    if options.property_files is None:
        raise AttributeError("No properties. Use -f to specify the properties to be tested.")
    
    if not str(options.apk_path).endswith((".apk", ".hap")):
        options.is_package = True
        COLOR_YELLOW = "\033[93m"
        COLOR_RESET = "\033[0m"
        print(f"{COLOR_YELLOW}Warning: {options.apk_path} is not a valid apk or hap file ... may be an app package name, trying to validate this app package ...{COLOR_RESET}")
        sanitize_app_package_name(options)
    else:
        options.is_package = False

def load_properties_from_dir(property_files):
    new_property_files = []
    for property_file in property_files:
        if os.path.isdir(property_file):
            print(f"load all the property files under: {property_file} ")
            try:
                for entry in os.listdir(property_file):
                    full_path = os.path.join(property_file, entry)
                    if os.path.isfile(full_path):
                        new_property_files.append(full_path)
            except Exception as e:
                print(e)
        else:
            new_property_files.append(property_file)
    return new_property_files

def save_log(logger, output_dir):
    # output logging into a txt file
    log_dir = os.path.join(output_dir, "records.log")
    file_handler = logging.FileHandler(log_dir)
    file_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

def identify_device_serial(options):
    """
    automatically identify the device serial
    When no devices or more than one device is connected, an exception will be thrown.
    When only one device is connected, the current device's serial is used. 
    """

    import subprocess
    if not options.is_harmonyos:
        cmd = ["adb", "devices"]
        r = subprocess.check_output(cmd, text=True)
        device_list = []
        for line in r.splitlines():
            if line and line.strip() != "List of devices attached":
                device_list.append(line.split()[0])
        if len(device_list) == 0:
            raise AttributeError("No connected device")
        if len(device_list) > 1:
            raise AttributeError("More than one attached devices, please specify one device serial")
        options.device_serial = device_list[0].strip()
    else:
        from .adapter.hdc import HDC_EXEC
        cmd = [HDC_EXEC, "list", "targets"]
        r = subprocess.check_output(cmd, text=True)
        device_list = [_.strip() for _ in r.splitlines()]
        if len(device_list) == 0:
            raise AttributeError("No connected device")
        if len(device_list) > 1:
            raise AttributeError("More than one attached devices, please specify one device serial")
        options.device_serial = device_list[0].strip()